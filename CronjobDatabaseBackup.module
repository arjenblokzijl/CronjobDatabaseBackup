<?php

/**
 * ProcessWire Module Cronjob Database Backup
 *
 * 
 * Auto backup your database periodically. Set interval in settings.
 * Use Process Database Backup Module to restore from backup or delete them.
 * This module could slow down your processes since backups may take some time,
 * depending on how much there is to backup.
 * 
 * made by kixe (Christoph Thelen) 05.11.14
 * Licensed under GNU/GPL v3
 *
 * some code taken from Ryans Module Database Backups (Thanks!)
 *
 * Database Backups
 * ProcessWire 2.x 
 * Copyright (C) 2014 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 * small ISSUES
 * #1 seems lazyCron is running twice. Always double entries in log file
 * #2 error message remains after correcting. page has to be reloaded.
 *
 */

class CronjobDatabaseBackup extends Process implements ConfigurableModule {

	public static function getModuleInfo() {
		return array(
			'title' => __('Cronjob Database Backup'), 
			'version' => 100,
			'summary' => __('Periodic automatic backup of the database. Set interval in settings. Use Process Database Backup Module to restore data or delete backups. This module could slow down your processes since data backup may take some time, depending on how much there is to backup.'),
			'autoload' => true,
			'singular' => true,
			'author' => 'kixe',
			'license' => 'GNU-GPLv3',
			'permission' => 'db-backup', // loggedin User must have this permission
			'hreflicense' => 'http://www.gnu.org/licenses/gpl-3.0.html',
			'requires' => array(
					'LazyCron',
					'ProcessDatabaseBackups'
					),
			'icon' => 'database'
		);
	}


	static public function getDefaultConfig() {
		return array(
			'cycle' => 0, // default set to never backup
		);
	}

	public function __construct() {
		foreach(self::getDefaultConfig() as $key => $value) {
			$this->$key = $value;
		}
	}

	protected $backup = null;

	/**
	* Initialize
	* hooks in Lazy Cron
	* set interval of script execution here
	* check syntax of hookable time functions in wire/modules/LazyCron.module
	*
	*/
	public function init() {
		$this->backup = $this->wire('database')->backups(); //WireDatabaseBackup Class
		if ($this->checkPath($this->wire('config')->paths->root.$this->field_storage_path)) $this->backup->setPath($this->wire('config')->paths->root.ltrim($this->field_storage_path,"/"));
		if ($this->cycle) $this->addHook("LazyCron::{$this->cycle}", $this, 'cronBackup');
		parent::init();
	}
	
	/**
	* checks wether a path exists or not - don't mind about leading or trailing slash
	* @return bool
	*/
	public function checkPath($path) {
		if($path && is_dir(ltrim($path,"/")) && is_writable(ltrim($path,"/"))) return true;
		return false;
	}

	/**
	* made by Ryan
	*
	*/
	protected function backupPath($short = false) {
		$path = $this->backup->getPath();
		if($short) $path = str_replace($this->wire('config')->paths->root, '/', $path); 
		return $path;
	}

	/**
	* hooky dooky
	*
	*/
	public function cronBackup(HookEvent $e) {
		$allTables = $this->backup->getAllTables();
		$database = $this->wire('database'); 

		$filename = ($this->backup_name)?$this->backup_name:$this->wire('config')->dbName;
		$_filename = $filename; 
		$filename .= '.sql';
		if(preg_match('/^(.+)-(\d+)$/', $_filename, $matches)) {
			$_filename = $matches[1]; 
			$n = $matches[2];
		} else {
			$n = 0; 
		}
		while(file_exists($this->backupPath() . $filename)) {
			$filename = $_filename . "-" . (++$n) . ".sql";
		}

		$options = array(
			'filename' => $filename, 
			'description' => "This backup was made by 'Cronjob Database Backup Module'"
			); 

		if(!$this->backup_all) {
			// selective tables
			$options['tables'] = array();
			foreach($this->tables as $table) {
				if(!isset($allTables[$table])) continue; 
				$options['tables'][] = $allTables[$table];
			}
		}

		$file = $this->backup->backup($options); 
		$message = $this->_("\ndatabackup saved by cronjob - path[").$file.']';
		$this->message($message,Notice::logOnly);
	}

	/**
	 * module settings
	 *
	 */
	static public function getModuleConfigInputfields(array $data) {

		$fields = new InputfieldWrapper();
		$modules = wire('modules');
		$database = wire('database');
		$config = wire('config');
		$defaults = self::getDefaultConfig();
		$data = array_merge($defaults, $data);
 
        $f = $modules->get("InputfieldSelect");
        $f->attr('name', 'cycle');
        $f->label = __("Backup Cycle Time");
        $f->description = __("Select a cycle time for your backups.");
        $f->notes = __("Leave blank to disable automatic backup. The cronjob to backup your database executes only if current user has db-backup permission.");
		$f->addOptions(array(
			0 => __(''),
			//'every30Seconds' =>__('30 seconds'), // for development use
			'everyDay' =>__('1 day'),
			'everyWeek' =>__('1 week'),
			'every2Weeks' =>__('2 weeks'),
			'every4Weeks'  =>__('4 weeks'),
            ));
        $f->value = $data['cycle'];
 		$fields->add($f);

		$def = $config->dbName;
		$f = $modules->get('InputfieldName'); 
		$f->attr('name', 'backup_name');
		$f->set('required', false);
		$f->label = __('Backup Name'); 
		$f->description = __('This will be used as the backup filename. Extension .sql will be added automatically.'); 
		$f->notes = __('If omitted, a unique filename will be automatically generated: [databasename]-[n].sql.'); 
		$f->value = $data['backup_name'];
		$fields->add($f); 

		$def = str_replace($config->paths->root,'',$database->backups()->getPath());
		$f = $modules->get('InputfieldText'); 
		$f->attr('name', 'field_storage_path');
		$f->set('required', false);
		$f->label = __('Storage Path'); 
		$f->description = __("Path to custom storage directory.");
		$f->notes = __("Leave this blank for storage under default path: $def");
		if($data['field_storage_path'] && !is_dir($config->paths->root.ltrim($data['field_storage_path'],"/"))) $f->error("Path doesn't exist! Default pass will be used.");
		elseif($data['field_storage_path'] && !is_writable($config->paths->root.ltrim($data['field_storage_path'],"/"))) $f->error("Path isn't writable! Default pass will be used.");
		$f->value = $data['field_storage_path'];
		$fields->add($f);

		$f = $modules->get('InputfieldCheckbox');
		$f->attr('name', 'backup_all'); 
		$f->label = __('Backup all tables?'); 
        $f->attr('checked', $data['backup_all'] ? 'checked' : '' );
		$fields->add($f);

		$f = $modules->get('InputfieldSelectMultiple'); 
		$f->attr('name', 'tables');
		$f->label = __('Tables'); 
		$f->description = __('By default, the export will include all tables. If you only want certain tables to be included, select them below.'); 
		$allTables = $database->backups()->getAllTables();
		foreach($allTables as $table) $f->addOption($table, $table); 
		$f->attr('value', $data['tables']?$data['tables']:$allTables); 
		$f->showIf = 'backup_all=0';
		$fields->add($f);

		return $fields;
	}

	public function ___uninstall() {
		$userpath = ($this->data['field_storage_path'])?"] and in [".trim($this->data['field_storage_path'],'/'):"";
		$defpath = $this->backupPath(true);
		$this->error(sprintf(__("Please note that maybe backup files in [%s%s] remain. If you don't want them there, please remove them manually."),$defpath,$userpath),Notice::warning); 
		parent::___uninstall();
	}

}
